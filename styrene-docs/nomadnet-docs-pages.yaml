apiVersion: v1
kind: ConfigMap
metadata:
  name: nomadnet-docs-pages
  namespace: reticulum
  labels:
    app.kubernetes.io/name: reticulum
    app.kubernetes.io/component: docs
data:
  architecture-decisions.mu: |
    `!Styrene Architecture!`
    
    > `*Document Type*`: Executive summary and decision record
    > `*Last Updated*`: 2026-02-19
    > `*Status*`: Active
    
    Styrene is a `*Reticulum*`-native fleet provisioning and management system for edge devices. It replaces fragile bash installer scripts with a robust, mesh-connected architecture enabling SSH-free device management through encrypted `*LXMF*` messaging.
    
    `*Document Hierarchy*`
    
    
    `*Distribution Model*`
    
    `*Key Decision: Isolated Package Dependencies*`
    
    Styrene is distributed as independent Python packages with explicit dependency relationships. This keeps coupling at the package boundary (dependency declaration + IPC/wire protocol) rather than deep library entanglement, enabling future rewrites of individual components in other languages (e.g., Rust).
    
    >>
    styrened (pip install styrened)
    ├── Standalone daemon + CLI + library
    ├── LXMF messaging core (NomadNet/MeshChat wire-compatible)
    ├── Styrene protocols (RPC, discovery, terminal)
    ├── IPC control server (Unix socket)
    └── Installable alone for headless/edge use; pre-installed in Styrix NixOS
    
    styrene-tui (pip install styrene-tui)
    ├── Depends: styrened (installing TUI pulls the daemon)
    ├── Forge provisioning (absorbed from styrene-edge)
    ├── LXMF inbox/chat (replaces NomadNet client + MeshChat for operators)
    ├── Fleet management (dashboard, device console, RPC)
    ├── Manages styrened lifecycle on operator workstations
    └── Single operator interface — one install, full stack
    
    styrene-edge (git clone, not pip — device support repo)
    ├── sbc/ NixOS configurations + flake (Styrix)
    ├── Device profiles YAML (consumed by TUI at runtime via remote fetch)
    ├── Polymerize scripts
    └── Contributors add device support here; operators never clone it
    
    reticulum hub (depends: styrened + nomadnet)
    ├── NomadNet BBS / hosted pages
    ├── LXMF propagation node
    └── Fleet coordination
    <<
    
    `*Installation scenarios:*`
    - `*Headless edge device*`: `pip install styrened` or pre-installed via Styrix NixOS
    - `*Operator workstation*`: `pip install styrene-tui` (pulls styrened automatically)
    - `*Community Hub*`: `styrened` + `nomadnet` as co-dependencies
    - `*Device contributor*`: `git clone styrene-edge`, work locally, submit PR
    
    `*Key Decision: TUI Manages Daemon Lifecycle*`
    
    On Styrix edge devices, styrened runs as a permanent systemd service. On an operator's workstation, the TUI manages styrened's lifecycle — starts it on launch, tears it down on exit. No `systemctl enable` required to use the TUI. The IPC contract (Unix socket) is the same in both cases; the TUI just owns the other end of the socket when there's no system daemon.
    
    `*Key Decision: styrene-edge as Upstream Device Support*`
    
    styrene-edge is a device support repository, not an application. It's the equivalent of a firmware tree or board support package. Contributors work there to add new device patterns (NixOS configs, device profiles, polymerize scripts). Operators never clone it.
    
    The TUI's provisioning flow fetches device profiles and NixOS configs from styrene-edge at runtime (GitHub raw, release artifact, or Cachix), the same way it fetches NixOS base layers from nixpkgs or the Cachix binary cache. When a contributor merges a new device PR, it appears in the TUI's catalog on next fetch.
    
    `*System Components*`
    
    >>
    ┌─────────────────────────────────────────────────────────────────────────┐
    │  Operator Workstation                                                    │
    │  ┌─────────────────────────────────────────────────────────────────┐    │
    │  │  styrene-tui (Python + Textual)                                 │    │
    │  │  ├── styrened (managed subprocess — owns mesh stack via IPC)    │    │
    │  │  ├── Forge provisioning (absorbed — media writer, bundles)      │    │
    │  │  ├── LXMF inbox/chat (replaces NomadNet/MeshChat client)       │    │
    │  │  ├── Fleet dashboard, device management, RPC                    │    │
    │  │  └── Device profiles fetched from styrene-edge at runtime       │    │
    │  └─────────────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────────────┘
                                        │
                        Styrene Wire Protocol over LXMF
                                        │
    ┌───────────────────────────────────┼───────────────────────────────────┐
    │                                   │                                    │
    │  ┌─────────────────┐    ┌────────┴────────┐    ┌─────────────────┐   │
    │  │  Styrene Hub    │    │  Mesh Router    │    │  Fleet Device   │   │
    │  │  (styrened +    │    │  (OpenWrt)      │    │  (Styrix)       │   │
    │  │   NomadNet)     │    │  • BATMAN-adv   │    │  • styrened     │   │
    │  │  • BBS pages    │    │  • 802.11s mesh │    │  • RPCServer    │   │
    │  │  • Propagation  │    │  • WiFi AP      │    │  • BATMAN-adv   │   │
    │  │  • Fleet coord  │    │                 │    │                 │   │
    │  └─────────────────┘    └─────────────────┘    └─────────────────┘   │
    │                                                                        │
    └────────────────────────────────────────────────────────────────────────┘
    <<
    
    `*Component Details:*`
    - `*styrene-tui*` → styrene-tui-vision.md (./styrene-tui-vision.md)
    - `*styrened (Device Daemon)*` → provisioning-vision.md#styrened (./provisioning-vision.md#styrened-unified-library--daemon)
    - `*Styrene Hub*` → provisioning-vision.md#styrene-hub (./provisioning-vision.md#styrene-hub-nomadnet-node)
    
    `*Network Architecture*`
    
    `*Layer Model*`
    
    In OSI terms, Reticulum replaces layers 3–6 (Network through Presentation) with cryptographic identity-based routing and end-to-end encryption. BATMAN-adv handles layer 2, and physical transports (WiFi, LoRa, Ethernet) provide layer 1. Standard internet protocols can coexist on the same hardware — the stack is backward-compatible, not a replacement.
    
    
    `*Key Decision: BATMAN-adv + Reticulum (Dual Layer)*`
    
    `*Why two layers?*` They solve different problems:
    
    - `*BATMAN-adv (L2)*`: "How do I get an Ethernet frame from radio A to radio B across 3 hops?"
      - Uses MAC addresses, measures real throughput, adapts to interference
      - Creates virtual switch across mesh nodes
    
    - `*Reticulum (Overlay)*`: "How do I send an encrypted message to cryptographic identity X?"
      - Uses 128-bit destination hashes, transport-agnostic
      - End-to-end encryption, identity-based routing
    
    Reticulum sees BATMAN-adv's `bat0` interface as just another network interface. The layers complement each other.
    
    → `*Details*`: provisioning-vision.md#layer-2-mesh-batman-adv (./provisioning-vision.md#layer-2-mesh-batman-adv)
    
    `*Key Decision: Graceful Degradation*`
    
    The network stack is designed to degrade gracefully as connectivity drops:
    
    
    BATMAN-adv provides the IP-compatible mesh for conventional traffic. RNS maintains mesh topology and path establishment. If proper backbones drop out, operations degrade to RNS-only — all fleet management commands, status checks, and terminal sessions continue to function because they ride LXMF, not IP.
    
    `*Key Decision: Styrix (NixOS Edge Flavor)*`
    
    `*Decision*`: The NixOS configuration for edge fleet devices is named `*Styrix*` (Styrax + Nix). Styrix is NixOS with styrened, RNS, BATMAN-adv, and the Imperial CRT console theme baked in.
    
    `*Rationale*`:
    - From the Styrax tree (etymological origin of "styrene") + Nix — places it in the styr- naming family (styrene, styryl, styrax, storax, styrix)
    - Not a fork — Styrix is opinionated NixOS configuration, not a separate distribution
    - Cross-platform polymerization doesn't need per-platform names ("Styrene for Android", "Styrene for Mac"), but the purpose-built NixOS edge substrate earns its own identity
    
    `*Scope*`: Styrix applies to edge fleet devices running NixOS. Operator workstations, containers, and non-NixOS platforms simply run styrened.
    
    `*Key Decision: NetworkManager for NixOS Fleet*`
    
    `*Decision*`: Standardize on NetworkManager with 802.11s mesh for all Styrix fleet devices.
    
    `*Rationale*`:
    - Consistent interface across RPi4B, Zero 2W, T100TA, x86 (MiniGMK, Q502L)
    - Robust 802.11s mesh support with automatic reconnection
    - ~15 MB RAM overhead acceptable even on 512 MB Zero 2W
    - nmcli/nmtui available for debugging
    
    `*Implementation*`: `batman-mesh.nix` module in `styrene-edge/sbc/common/`
    
    `*Configuration Decisions*`
    
    `*Mesh Key: Fleet-Wide Shared*`
    
    `*Decision*`: Single PSK shared across all devices in a fleet.
    
    `*Rationale*`:
    - Reticulum provides end-to-end encryption for all application traffic
    - Mesh key only controls L2 access (who can join the mesh)
    - Small trusted fleet doesn't benefit from per-device key complexity
    - Easy rotation: change in Vault, re-provision or push via Polymerize RPC
    
    `*Storage*`: Vault secret, injected at provision time.
    
    `*Gateway Mode: Per-Instance Configuration*`
    
    `*Decision*`: Gateway mode is deployment-specific, not device-type specific.
    
    
    `*Offline Operation*`: Set all nodes to `gw_mode=off`. Mesh works for internal communication without internet.
    
    `*Configuration*`: Set in `mesh.conf` (OpenWrt) or NixOS module option at provision time.
    
    `*Styrix Module: batman-mesh.nix*`
    
    All Styrix fleet devices import a common module providing:
    - `batman-adv` kernel module
    - `batctl` package  
    - NetworkManager 802.11s mesh profile
    - systemd service to attach interface to `bat0`
    
    `*Options*`:
    >>
    styrene.mesh = {
      enable = true;
      meshId = "styrene";
      meshKey = "fleet-key-from-vault";
      channel = 6;
      gwMode = "client";  # or "server" or "off"
    };
    <<
    
    `*TUI Integration Points*`
    
    
    `*Implementation Phases*`
    
    
    → `*Details*`: styrene-tui-vision.md#implementation-phases (./styrene-tui-vision.md)
    
    `*Wire Protocol Summary*`
    
    
    `*Message Type Ranges (StyreneMessageType enum)*`:
    - 0x01-0x0F: Control (PING, PONG, HEARTBEAT)
    - 0x10-0x1F: Status (STATUS_REQUEST, STATUS_RESPONSE)
    - 0x40-0x5F: RPC Commands (EXEC, REBOOT, CONFIG_UPDATE)
    - 0x60-0x7F: RPC Responses (EXEC_RESULT, REBOOT_RESULT)
    - 0xC0-0xCF: Terminal Sessions (TERMINAL_REQUEST, TERMINAL_ACCEPT)
    
    → `*Details*`: provisioning-vision.md#fleet-communication-protocol (./provisioning-vision.md#fleet-communication-protocol)
    
    `*Open Questions*`
    
    
    `*Document Maintenance*`
    
    `*Keeping Documents in Sync*`
    
    When updating Styrene architecture:
    
    1. `*Decision changes*` → Update architecture-decisions.md first, then update detail docs
    2. `*Implementation details*` → Update vision docs, verify architecture-decisions.md links still valid
    3. `*New components*` → Add to architecture-decisions.md with link to new/existing detail doc
    
    `*Drift Prevention Checklist*`
    
    Before committing changes to any Styrene document:
    - [ ] architecture-decisions.md reflects current decisions
    - [ ] Cross-document links are valid
    - [ ] No contradictions between documents
    - [ ] Revision history updated in modified docs
    
    `*Document Ownership*`
    
    
    `*Claude Code Directive*`
    
    When working on Styrene-related code:
    1. Read architecture-decisions.md first for current decisions
    2. Follow links to relevant detail docs for implementation specifics
    3. After making architectural changes, update architecture-decisions.md
    4. Verify cross-document consistency before committing
    
    `*References*`
    
    - provisioning-vision.md (./provisioning-vision.md) - Full provisioning architecture
    - styrene-tui-vision.md (./styrene-tui-vision.md) - TUI design and phases
    - Reticulum Documentation (https://reticulum.network/manual/)
    - BATMAN-adv Documentation (https://www.open-mesh.org/doc/batman-adv/Doc-overview.html)
    - NetworkManager 802.11s (https://networkmanager.dev/)
    
    `*Revision History*`
    

  architecture.mu: |
    `!Architecture!`
    
    Styrene is a `*Reticulum*`-native fleet management system. This document describes the system architecture, network design, and protocol decisions.
    
    `*System Overview*`
    
    >>
    ┌─────────────────────────────────────────────────────────────────────────┐
    │  Operator Workstation                                                    │
    │  ┌─────────────────────────────────────────────────────────────────┐    │
    │  │  Styrene TUI (Python + Textual)                                 │    │
    │  │  • Device detection, image writing                              │    │
    │  │  • Fleet dashboard, device management                           │    │
    │  │  • RPC client (LXMF)                                            │    │
    │  └─────────────────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────────────────┘
                                        │
                        Reticulum Mesh (LXMF RPC)
                                        │
    ┌───────────────────────────────────┼───────────────────────────────────┐
    │                                   │                                    │
    │  ┌─────────────────┐    ┌────────┴────────┐    ┌─────────────────┐   │
    │  │  Styrene Hub    │    │  Mesh Router    │    │  Fleet Device   │   │
    │  │  (NomadNet)     │    │  (OpenWrt)      │    │  (Styrix)       │   │
    │  │  • Device specs │    │  • BATMAN-adv   │    │  • styrened     │   │
    │  │  • Fleet config │    │  • 802.11s mesh │    │  • RPCServer    │   │
    │  │  • Identity reg │    │  • WiFi AP      │    │  • BATMAN-adv   │   │
    │  └─────────────────┘    └─────────────────┘    └─────────────────┘   │
    │                                                                        │
    └────────────────────────────────────────────────────────────────────────┘
    <<
    
    `*Network Layers*`
    
    Styrene uses a dual-layer network architecture:
    
    
    `*Why Two Layers?*`
    
    **`*BATMAN-adv*` (Layer 2)**: Solves physical connectivity — getting Ethernet frames across multiple wireless hops. It uses MAC addresses, measures real throughput, and adapts to interference.
    
    **`*Reticulum*` (Overlay)**: Solves logical connectivity — sending encrypted messages to cryptographic identities. It's transport-agnostic and provides end-to-end encryption.
    
    `*Reticulum*` sees `*BATMAN-adv*`'s `bat0` interface as just another network interface. The layers complement each other.
    
    `*Communication Protocol*`
    
    Fleet communication uses `*LXMF*` (Lightweight Extensible Message Format) over `*Reticulum*`.
    
    `*Request/Response Pattern*`
    
    All messages include a 16-byte `request_id` for correlation. The wire format is binary (msgpack), not JSON — shown here as pseudo-structure for clarity:
    
    >>
    TUI → Device:
      [styrene.io:][0x02][0x10][<16-byte-request-id>][<empty payload>]
    
    Device → TUI:
      [styrene.io:][0x02][0x11][<16-byte-request-id>][msgpack({
        "uptime": 123456,
        "ip": "192.168.0.101",
        "services": ["reticulum", "styrened"]
      })]
    <<
    
    `*Message Types*`
    
    
    `*Security Model*`
    
    - All messages encrypted end-to-end via `*Reticulum*` identity keys
    - Devices only accept commands from authorized operator identities
    - Identity authorization configured at provision time
    
    `*Data Flow*`
    
    `*Provisioning (x86 — USB Installer)*`
    
    >>
    1. Operator launches Styrene Forge (styrene-edge)
    2. Forge detects USB drives, shows device catalog
    3. Operator selects device type, configures hostname/WiFi/SSH
    4. Forge writes bootable USB (ISO + configs + polymerize.sh)
    5. Operator boots target from USB, runs polymerize.sh
    6. polymerize.sh partitions disk, runs nixos-install
    7. Device reboots into NixOS with styrened
    8. Reticulum service starts, announces identity
    9. Device appears in TUI fleet dashboard
    <<
    
    `*Provisioning (ARM — Direct SD)*`
    
    >>
    1. Build SD image: nix build ./sbc#packages.aarch64-linux.rpi4-sd
    2. Write image to SD card
    3. Insert SD, power on — NixOS boots directly
    4. styrened starts, announces on mesh
    5. Device appears in TUI fleet dashboard
    <<
    
    `*Fleet Management*`
    
    >>
    1. TUI shows fleet dashboard
    2. Operator selects device
    3. TUI sends status_request via LXMF
    4. Device responds with status_response
    5. Operator sends commands, views results
    <<
    
    `*Configuration Decisions*`
    
    `*Mesh Key: Fleet-Wide Shared*`
    
    A single PSK is shared across all devices in a fleet. This is acceptable because:
    
    - `*Reticulum*` provides end-to-end encryption for application traffic
    - Mesh key only controls L2 access (who can join the mesh)
    - Small trusted fleets don't benefit from per-device key complexity
    
    `*Gateway Mode*`
    
    
    `*Styrene Hub*`
    
    The Hub is a `*NomadNet*` node that serves as the fleet's configuration authority.
    
    `*Responsibilities:*`
    - Device specifications (partition layouts, bootloader requirements)
    - `*NixOS*` configuration templates
    - Fleet manifests
    - Identity registry
    - ISO hashes for integrity verification
    
    `*Hub Role in RPC:*`
    - Acts as propagation node for `*LXMF*` messages
    - Provides device discovery endpoint
    - Does NOT intercept RPC (direct TUI ↔ Device communication)
    
    `*Bandwidth Considerations*`
    
    
    The mesh handles control plane traffic. Large downloads use internet with integrity verified via Hub-provided hashes.
    
    `*References*`
    
    - `*Reticulum Network*`
    - `*LXMF Protocol*`
    - `*BATMAN-adv*`
    - `*NomadNet*`

  components.mu: |
    `!Components!`
    
    Styrene consists of three main components: a TUI application, a headless daemon (which also serves as the shared library), and infrastructure-as-code for edge devices.
    
    `*styrene-tui*`
    
    The operator terminal interface built on the `*Textual*` framework.
    
    
    `*Screens*`
    
    - `*Dashboard*` — Fleet overview with device status
    - `*Inbox*` — `*LXMF*` message handling
    - `*Conversation*` — Direct device communication
    - `*Device Console*` — Command execution
    - `*Device Detail*` — Single device information
    - `*Provision Flow*` — Media preparation wizard
    - `*Settings*` — Configuration management
    - `*First-Run Wizard*` — Initial setup
    - `*Exploration*` — Network discovery
    
    `*Widgets*`
    
    - Device status indicators
    - Command input
    - Progress panels
    - Hardware pickers
    - Configuration forms
    - Animated status displays
    
    `*Theme: Imperial CRT*`
    
    The TUI uses a retro green phosphor terminal aesthetic:
    
    >>
    ┌─ Imperial CRT Phosphor Palette ──────────────────────────┐
    │  Bright:  #39ff14  Active elements, highlights, success  │
    │  Medium:  #32cd32  Standard text, borders                │
    │  Dim:     #228b22  Secondary text, inactive elements     │
    │  Dark:    #1a5c1a  Subtle borders, separators            │
    │  Background: #0a0a0a                                     │
    └──────────────────────────────────────────────────────────┘
    <<
    
    `*Installation*`
    
    >>
    cd styrene-tui
    uv pip install -e .
    <<
    
    `*Running*`
    
    >>
    styrene
    <<
    
    ---
    
    `*styrened*`
    
    Unified headless daemon and shared library for the Styrene mesh. Provides both the edge device daemon and the library consumed by styrene-tui.
    
    
    `*As Library (used by styrene-tui)*`
    
    - RPC client/server implementations
    - Wire protocol v2 encoding/decoding
    - Message models and data structures
    - Service lifecycle management (LXMFService, ConfigService, NodeStore)
    - Device discovery and conversation services
    
    `*As Daemon (runs on edge devices)*`
    
    - RPCServer — fleet management commands
    - AutoReplyHandler — responds to NomadNet/MeshChat users
    - Device Discovery + NodeStore — persistent mesh topology
    - TerminalService — remote shell via PTY over RNS Link
    - IPC Control Server — Unix socket for local CLI
    - HTTP API — optional REST endpoints
    
    `*Installation*`
    
    >>
    pip install styrened                    # PyPI
    nix run github:styrene-lab/styrened     # Nix flake
    <<
    
    `*NixOS Integration*`
    
    >>
    {
      imports = [ ../common/styrened.nix ];
      styrene.daemon.enable = true;
    }
    <<
    
    ---
    
    `*styrene-edge*`
    
    Infrastructure-as-code and provisioning toolchain for the hardware fleet.
    
    
    `*Active Devices*`
    
    
    `*Usage*`
    
    >>
    # Build SD card image for RPi 4 (fetches from Cachix)
    nix build ./sbc#packages.aarch64-linux.rpi4-sd
    
    # Launch Forge TUI for USB media preparation
    just run
    
    # Run polymerize.sh on target device after booting USB
    sudo /iso/styrene/polymerize.sh
    <<
    
    `*Structure*`
    
    >>
    styrene-edge/
    ├── sbc/
    │   ├── flake.nix               # Nix flake for SD card images
    │   ├── common/
    │   │   ├── base.nix            # styrene.base NixOS module (shared config)
    │   │   ├── batman-mesh.nix     # styrene.mesh BATMAN-adv module
    │   │   ├── styrened.nix        # styrene.daemon module
    │   │   └── cosmic-desktop.nix  # styrene.desktop COSMIC DE module
    │   ├── rpi4/configuration.nix
    │   ├── rpi-zero2w/configuration.nix
    │   ├── x86-generic/
    │   │   ├── configuration.nix
    │   │   └── polymerize.sh       # NixOS installer for UEFI x86
    │   └── t100ta/
    │       ├── configuration.nix
    │       └── polymerize.sh       # NixOS installer for 32-bit UEFI
    ├── forge/                      # Styrene Forge (media prep TUI)
    │   ├── data/devices.yaml       # Device catalog
    │   └── services/
    │       ├── media_writer.py     # USB/SD media writer
    │       └── bundle_builder.py   # Config bundler
    ├── installs/                   # Runbook tracking
    ├── mcu/                        # Microcontrollers (RP2040, ESP32, nRF)
    └── router/                     # OpenWrt mesh routers
    <<
    
    ---
    
    `*styrene-plugin*`
    
    Claude Code plugin providing domain-specific skills, agents, and commands for styrene development.
    
    
    `*Skills*`
    
    
    `*Agents*`
    
    
    `*Commands*`
    
    
    ---
    
    `*Relationship Diagram*`
    
    >>
    ┌─────────────┐         ┌─────────────┐
    │ styrene-tui │         │ styrene-edge│
    │  (operator) │         │ (IaC/Forge) │
    └──────┬──────┘         └──────┬──────┘
           │ uses as library       │ deploys
           ▼                       ▼
    ┌──────────────────────────────────────┐
    │  styrened (daemon + shared library)   │
    │  Models, Protocols, RPC, Services     │
    └──────────────────────────────────────┘
    <<
    
    `*See Also*`
    
    - `[Architecture`:/page/architecture.mu] — System design overview
    - `[Getting Started`:/page/getting-started.mu] — Installation guide
    - `[Hardware`:/page/hardware.mu] — Supported devices
    - styrene-plugin (https://github.com/styrene-lab/styrene-plugin) — Claude Code plugin repo

  getting-started.mu: |
    `!Getting Started!`
    
    This guide walks you through installing Styrene and provisioning your first edge device.
    
    `*Prerequisites*`
    
    - Python 3.11+
    - uv (https://github.com/astral-sh/uv) (recommended) or pip
    - A USB drive or SD card for bootable media
    - Target hardware (see `[Hardware`:/page/hardware.mu] for supported devices)
    
    `*Installation*`
    
    `*From Source*`
    
    >>
    # Clone the repositories
    git clone https://github.com/styrene-lab/styrened.git
    git clone https://github.com/styrene-lab/styrene-tui.git
    
    # Install styrened (daemon + shared library)
    cd styrened
    uv pip install -e .
    
    # Install styrene-tui
    cd ../styrene-tui
    uv pip install -e .
    <<
    
    `*From PyPI*`
    
    >>
    pip install styrened    # Library + daemon
    pip install styrene-tui # TUI (pulls styrened as dependency)
    <<
    
    `*First Run*`
    
    Launch the TUI:
    
    >>
    styrene
    <<
    
    On first run, `*Styrene*` will:
    1. Generate a `*Reticulum*` identity (stored in `~/.config/styrene/`)
    2. Initialize the configuration directory
    3. Display the first-run wizard
    
    `*Provisioning a Device*`
    
    `*1. Insert Storage Media*`
    
    Insert a USB drive or SD card. Styrene detects removable storage automatically.
    
    `*2. Select Device Type*`
    
    Choose your target hardware from the device picker:
    
    - `minigmk` — GMKtec NucBox G3 Plus (x86_64 UEFI)
    - `q502l` — ASUS Q502LA (x86_64 UEFI)
    - `t100ta` — ASUS T100TA (32-bit UEFI, Bay Trail)
    - `rpi4` — Raspberry Pi 4 (aarch64, direct SD)
    - `rpi-zero2w` — Raspberry Pi Zero 2W (aarch64, direct SD)
    
    `*3. Configure*`
    
    Enter the required configuration:
    
    - `*Hostname*` — Device name on the network
    - `*WiFi SSID/PSK*` — Network credentials (optional)
    - `*SSH Keys*` — Your public key for initial access
    
    Press `E` to edit the full `*NixOS*` configuration in your `$EDITOR`.
    
    `*4. Write Media*`
    
    For x86 devices, use Styrene Forge (`just run` in styrene-edge):
    
    1. Forge downloads the `*NixOS*` ISO (cached after first use)
    2. Writes to USB with configs, WiFi, SSH keys bundled
    3. Includes `polymerize.sh` installer script
    
    For ARM SBCs (RPi), build an SD image:
    
    >>
    nix build ./sbc#packages.aarch64-linux.rpi4-sd
    # Write the resulting image to SD card
    <<
    
    `*5. Boot and Install*`
    
    `*x86 (USB installer):*`
    1. Boot target from USB
    2. Run `sudo /iso/styrene/polymerize.sh`
    3. Follow the semi-attended installation
    
    `*ARM (direct SD):*`
    1. Insert SD card and power on — NixOS boots directly
    2. SSH in as `styrene` (password: `styrene`)
    
    `*6. Fleet Registration*`
    
    After installation completes and the device reboots:
    
    1. The device starts its `*Reticulum*` identity
    2. Announces on the mesh network
    3. Appears in your TUI fleet dashboard
    
    `*Configuration*`
    
    Styrene stores configuration in `~/.config/styrene/`:
    
    >>
    ~/.config/styrene/
    ├── config.yaml          # Main configuration
    ├── identity/            # Reticulum identity
    ├── devices/             # Device specifications
    └── fleet/               # Fleet inventory
    <<
    
    `*config.yaml*`
    
    >>
    # Styrene configuration
    editor: $EDITOR  # Falls back to vi
    
    # Default provisioning options
    defaults:
      ssh_key: ~/.ssh/id_ed25519.pub
    
    # Reticulum configuration
    reticulum:
      config_path: ~/.config/reticulum
    <<
    
    `*Next Steps*`
    
    - `[Architecture`:/page/architecture.mu] — Understand how Styrene works
    - `[Components`:/page/components.mu] — Explore each component in depth
    - `[Hardware`:/page/hardware.mu] — See recommended hardware for deployment

  hardware.mu: |
    `!Hardware!`
    
    Styrene supports a range of ARM and x86 hardware for edge deployment. This document covers recommended boards, supported platforms, and hardware selection guidance.
    
    `*Recommended Boards*`
    
    
    `*Supported SoCs*`
    
    `*Rockchip Family*`
    
    
    `*MediaTek Genio Family*`
    
    
    `*Boards by Form Factor*`
    
    `*Compact Router / Gateway (≤60×60mm)*`
    
    
    `*Raspberry Pi Form Factor (~85×56mm)*`
    
    
    `*Full-Size SBC (~100×75mm+)*`
    
    
    `*Power Profiles*`
    
    `*Ultra-Low Power (≤5W typical)*`
    
    
    `*Low Power (5-10W typical)*`
    
    
    `*Standard Power (10-20W typical)*`
    
    
    `*NixOS Compatibility*`
    
    `*Confirmed Working*`
    
    - **`*Radxa-ROCK-5-ITX*`** — `*NixOS*` Wiki documented, EDK2 UEFI
    - **`*Radxa-ROCK-5B*`** — gnull/nixos-rk3588 flake
    - **`*Orange-Pi-5*`/`*5 Plus*`** — Community tested
    - **`*NanoPi-R6S*`/`*NanoPi-R6C*`** — Armbian kernel + `*NixOS*` rootfs
    
    `*Path to NixOS*`
    
    >>
    1. Flash EDK2 UEFI (RK3588 boards) or U-Boot
    2. Boot generic aarch64 NixOS ISO
    3. Use hardware.deviceTree for board-specific DTB
    4. Kernel 6.12+ required for RK3588 display
    <<
    
    `*Vendor Assessment*`
    
    
    `*Immediate Deployment: NanoPi R5C*`
    
    The `*NanoPi-R5C*` is the pragmatic choice for immediate deployment.
    
    `*Why this board:*`
    - Dual 2.5GbE for modern networks
    - Compact 58×58mm with CNC metal case
    - `*RK3568*` has mature mainline kernel support (6.1+)
    - FriendlyWrt (OpenWrt fork) ready out of box
    - M.2 E-key for optional WiFi/BT
    
    `*Specifications:*`
    
    `*Pricing:*`
    - 4GB + metal case direct from FriendlyELEC: $64
    - Amazon (US): $75-95
    
    `*Purchase:*` FriendlyELEC (https://www.friendlyelec.com/index.php?route=product/product&product_id=290)
    
    `*Input Devices*`
    
    For operator interface hardware, compact QWERTY keyboards compatible with edge devices:
    
    
    `*Use Cases*`
    
    `*Mesh Gateway*`
    - `*Recommended:*` `*NanoPi-R5C*`
    - Dual 2.5GbE, low power, metal enclosure
    
    `*Edge AI Inference*`
    - `*Recommended:*` `*Radxa-ROCK-4D*` or `*NanoPi-R76S*`
    - 6 TOPS NPU for local inference
    
    `*Long-Term Industrial*`
    - `*Recommended:*` `*Radxa-NIO-12L*`
    - 10-year lifecycle commitment, mainline kernel
    
    `*Home Lab / NAS*`
    - `*Recommended:*` `*Orange-Pi-5-Plus*`
    - Dual 2.5GbE, NVMe support, high RAM options
    
    `*See Also*`
    
    - `[Components`:/page/components.mu] — Software for these devices
    - `[Architecture`:/page/architecture.mu] — Network design
    - `[Getting Started`:/page/getting-started.mu] — Provisioning workflow

  index.mu: |
    `!Styrene!`
    
    Mesh MANET fleet management for edge devices.
    
    Styrene is a `*Reticulum*`-native provisioning and management system that replaces fragile bash scripts with a robust, mesh-connected architecture. Manage your edge fleet over encrypted channels without SSH.
    
    `*What is Styrene?*`
    
    Styrene provides:
    
    - `*TUI-driven provisioning*` — Prepare bootable `*NixOS*` media from a terminal interface
    - `*Mesh fleet management*` — Monitor and control devices over `*Reticulum*`/`*LXMF*`
    - `*SSH-free operations*` — All communication encrypted via Reticulum identity keys
    - `*Edge-first design*` — Runs on everything from Raspberry Pi Zero to x86 laptops
    
    `*Architecture*`
    
    >>
    ┌─────────────────┐     ┌─────────────────┐
    │   styrene-tui   │     │  styrene-edge   │
    │   (operator)    │     │   (IaC/Forge)   │
    └────────┬────────┘     └────────┬────────┘
             │ uses as library       │ deploys
             └───────────┬───────────┘
                         │
                  ┌──────▼──────┐
                  │   styrened   │
                  │(daemon+lib)  │
                  └──────┬───────┘
                         │
                  ┌──────▼──────┐
                  │  Reticulum   │
                  │    Network   │
                  └──────────────┘
    <<
    
    **`*styrene-tui*`** is the operator interface — a `*Textual*`-based terminal application for provisioning devices and managing the fleet.
    
    **`*styrened*`** is the unified daemon and shared library — provides both the edge device daemon (RPCServer, AutoReply, Discovery) and the library consumed by styrene-tui (`*Reticulum*` integration, protocols, RPC primitives).
    
    **`*styrene-edge*`** is infrastructure-as-code — NixOS configurations, Styrene Forge (media preparation TUI), and provisioning toolchain.
    
    `*Quick Links*`
    
    - `[Getting Started`:/page/getting-started.mu] — Install and run Styrene
    - `[Architecture`:/page/architecture.mu] — System design and protocols
    - `[Components`:/page/components.mu] — Detailed component documentation
    - `[Hardware`:/page/hardware.mu] — Supported devices and recommendations
    
    `*Project Status*`
    
    
    `*External Links*`
    
    - GitHub (https://github.com/styrene-lab)
    - Reticulum Network (https://reticulum.network/)

  nav.mu: |
    `!Styrene Documentation!`
    
    Navigate to a page:
    
    - `[Styrene`:/page/index.mu]
    - `[Styrene Provisioning Vision`:/page/provisioning-vision.mu]
    - `[Architecture`:/page/architecture.mu]
    - `[Hardware`:/page/hardware.mu]
    - `[Styrene TUI Vision`:/page/styrene-tui-vision.mu]
    - `[Getting Started`:/page/getting-started.mu]
    - `[Styrene Architecture`:/page/architecture-decisions.mu]
    - `[Components`:/page/components.mu]

  provisioning-vision.mu: |
    `!Styrene Provisioning Vision!`
    
    A Reticulum-native fleet provisioning system for edge devices.
    
    `*Status*`: Active — Last aligned with implementation 2026-02-19
    
    > `*Architecture Reference*`: See architecture-decisions.md (./architecture-decisions.md) for high-level decisions and document hierarchy.
    
    `*Overview*`
    
    Styrene Provisioning provides robust, mesh-connected provisioning and fleet management for edge devices. The system consists of:
    
    1. `*styrened*` — Base layer daemon + library, installed on every device (edge, operator, hub)
    2. `*styrene-tui*` — Operator TUI (depends on styrened; absorbs Forge provisioning; replaces NomadNet/MeshChat as LXMF client)
    3. `*styrene-edge*` — Upstream device support repo (NixOS configs, device profiles, polymerize scripts — fetched at runtime by TUI)
    4. `*Reticulum Mesh*` — LXMF communication with custom Styrene wire protocol
    
    > `*Architecture Note*`: styrened is the base layer on every device. The TUI is an optional UI layer that some devices get. On operator workstations, the TUI manages styrened as a subprocess (no permanent systemd service required). On edge devices, styrened runs as a permanent systemd service. The IPC contract (Unix socket) is the same in both cases.
    
    > `*Distribution Note*`: Packages are kept as isolated dependencies with coupling at the package boundary (pip dependency + IPC/wire protocol). This enables future rewrites of individual components in other languages (e.g., Rust) — a new implementation only needs to honor the wire protocol and socket contract, not maintain Python API compatibility.
    
    `*Architecture*`
    
    >>
    ┌─────────────────────────────────────────────────────────────────────────────┐
    │  Operator Workstation                                                        │
    │  ┌───────────────────────────────────────────────────────────────────────┐  │
    │  │  styrene-tui (Python + Textual)                                       │  │
    │  │  ├── styrened (managed subprocess — owns mesh stack via IPC)          │  │
    │  │  ├── Forge provisioning (absorbed — media writer, disk detect)        │  │
    │  │  ├── LXMF inbox/chat (replaces NomadNet/MeshChat client)             │  │
    │  │  ├── Fleet dashboard (live status via styrened IPC)                    │  │
    │  │  ├── Device profiles fetched from styrene-edge at runtime             │  │
    │  │  └── Hub Browser (NomadNet page viewer) [TODO]                        │  │
    │  └───────────────────────────────────────────────────────────────────────┘  │
    └─────────────────────────────────────────────────────────────────────────────┘
             │                              │
             │ Internet (NixOS images,      │ Styrene Wire Protocol over LXMF
             │  device profiles, Cachix)    │
             ▼                              ▼
    ┌─────────────────────┐    ┌─────────────────────────────────────────────────┐
    │  cache.nixos.org    │    │  Styrene Hub (styrened + NomadNet)               │
    │  styrene.cachix.org │    │  ├── BBS / hosted pages                        │
    │  github:styrene-lab │    │  ├── LXMF propagation node                      │
    │   /styrene-edge     │    │  └── Fleet coordination                         │
    └─────────────────────┘    └─────────────────────────────────────────────────┘
                                                │
                                                │ Styrene Wire Protocol over LXMF
                                                ▼
    ┌─────────────────────────────────────────────────────────────────────────────┐
    │  Target Device (running Styrix)                                              │
    │  ┌───────────────────────────────────────────────────────────────────────┐  │
    │  │  styrened (v0.4.0+) - Headless daemon (systemd service)               │  │
    │  │  ├── RPCServer (STATUS_REQUEST, EXEC, REBOOT, CONFIG_UPDATE)          │  │
    │  │  ├── AutoReplyHandler (respond to NomadNet/MeshChat users)            │  │
    │  │  ├── Device Discovery + NodeStore (persistent mesh topology)          │  │
    │  │  ├── IPC Control Server (Unix socket for local CLI/TUI)               │  │
    │  │  ├── ConversationService (chat history, delivery tracking)            │  │
    │  │  ├── ReadReceiptProtocol (ecosystem compatibility)                    │  │
    │  │  ├── HTTP API (optional, for local status/control)                    │  │
    │  │  └── TerminalService (PTY over RNS Link)                              │  │
    │  └───────────────────────────────────────────────────────────────────────┘  │
    └─────────────────────────────────────────────────────────────────────────────┘
    <<
    
    `*Components*`
    
    `*styrened (Unified Library + Daemon)*`
    
    The core Styrene package providing both library functionality and headless daemon.
    
    `*Design principle — infrastructure-by-default:*` Every styrened instance is a full LXMF peer on the mesh, acting as a transport participant and propagation point simply by running. Most mesh users connect transiently; styrened devices are persistent infrastructure, growing mesh reliability as a side effect of fleet operations. Standard LXMF clients (Sideband, MeshChat, NomadNet) see styrened as a normal messaging peer — the Styrene wire protocol rides inside LXMF `FIELD_CUSTOM_TYPE`, invisible to non-Styrene participants.
    
    `*Package:*` `styrened` v0.4.0+ (GitHub (https://github.com/styrene-lab/styrened))
    
    `*As Library (used by styrene-tui):*`
    - RPC client/server implementations
    - Wire protocol encoding/decoding
    - Message models and data structures
    - Service lifecycle management
    - Config management
    
    `*As Daemon (runs on edge devices):*`
    - `*RPCServer*` — Handles incoming fleet management requests
    - `*AutoReplyHandler*` — Responds to NomadNet/MeshChat users
    - `*Device Discovery + NodeStore*` — Tracks mesh topology via RNS announces (persistent)
    - `*ConversationService*` — Chat history, message delivery tracking, threading
    - `*ReadReceiptProtocol*` — Ecosystem compatibility with Sideband/MeshChat
    - `*IPC Control Server*` — Unix socket for local CLI/TUI communication
    - `*TerminalService*` — Remote shell access via PTY over RNS Link
    - `*HTTP API*` — Optional REST endpoints for status/control
    
    `*Installation:*`
    >>
    pip install styrened                    # PyPI
    nix run github:styrene-lab/styrened     # Nix flake
    docker pull ghcr.io/styrene-lab/styrened:latest  # Container
    <<
    
    `*styrene-tui (Operator Interface)*`
    
    The single operator interface for Styrene — provisioning, fleet management, and mesh communication in one TUI.
    
    `*Package:*` `styrene-tui` (GitHub (https://github.com/styrene-lab/styrene-tui))
    
    `*Dependencies:*` `styrened` (installing the TUI pulls the daemon automatically)
    
    `*Daemon Lifecycle:*` On operator workstations, the TUI manages styrened as a subprocess — starts it on launch, tears it down on exit. No permanent systemd service required. On edge devices where styrened runs as a systemd service, the TUI connects to the existing daemon via IPC. The Unix socket contract is the same in both cases.
    
    `*Capabilities:*`
    - `*Forge provisioning*` (absorbed from styrene-edge) — media writer, disk detection, bundle builder, device catalog
    - `*LXMF inbox/chat*` — replaces NomadNet client and MeshChat for operators; full LXMF ecosystem compatibility
    - `*Fleet management*` — dashboard with live device status, RPC commands (status, exec, reboot, config)
    - `*Device detection*` (USB, SD, SATA, NVMe)
    - `*Device profiles*` fetched from styrene-edge at runtime (GitHub, release artifacts, or Cachix)
    - [TODO] Browse Styrene Hub via NomadNet protocol
    
    `*styrene-edge (Device Support Repository)*`
    
    styrene-edge is an upstream device support repo — the equivalent of a firmware tree or board support package. Contributors work here to add new device patterns; operators never clone it.
    
    `*Repository:*` `styrene-edge` (GitHub (https://github.com/styrene-lab/styrene-edge))
    
    `*Components:*`
    - `sbc/<device>/configuration.nix` — Per-device NixOS configurations
    - `sbc/common/` — Shared NixOS modules (base.nix, styrened.nix, batman-mesh.nix)
    - `sbc/flake.nix` — Nix flake producing SD card images via `nix build`
    - `forge/data/devices.yaml` — Device catalog (specs, boot types, config paths)
    - `sbc/<device>/polymerize.sh` — Per-device installer scripts (x86)
    
    `*Runtime consumption:*` The TUI fetches device profiles and NixOS configs from styrene-edge at runtime, the same way `nix build github:styrene-lab/styrene-edge#rpi4-sd` resolves the flake reference remotely. When a contributor merges a new device PR, it appears in the TUI's catalog on next fetch.
    
    `*Polymerize scripts (`polymerize.sh`):*`
    - Per-device-type installer scripts in `sbc/<device>/polymerize.sh`
    - Semi-attended NixOS installation: partition, format, nixos-install
    - Reads injected config from USB media bundle
    - Supports WiFi auto-config, SSH key injection, hostname baking
    
    `*SD card images (ARM):*`
    - `sbc/flake.nix` produces direct-boot SD images via `nix build`
    - Cachix binary cache (`styrene.cachix.org`) serves pre-built aarch64 images
    - No installer script needed — SD card IS the root filesystem
    
    `*Fleet Communication (Styrene Wire Protocol)*`
    
    Devices communicate using a `*custom Styrene wire protocol*` over LXMF:
    
    `*Wire Format v2:*`
    >>
    [PREFIX:11][VERSION:1][TYPE:1][REQUEST_ID:16][PAYLOAD:N]
    PREFIX: b"styrene.io:"
    VERSION: 2
    TYPE: StyreneMessageType enum (0x00-0xFF)
    REQUEST_ID: 16 bytes for correlation (random or NO_CORRELATION)
    PAYLOAD: msgpack-encoded data
    <<
    
    `*Message Type Ranges:*`
    - 0x01-0x0F: Control (PING, PONG, HEARTBEAT)
    - 0x10-0x1F: Status (STATUS_REQUEST/RESPONSE)
    - 0x20-0x2F: Content (CHAT, FILE_*)
    - 0x30-0x3F: Network (ANNOUNCE, PEER_*)
    - 0x40-0x5F: RPC Commands (EXEC, REBOOT, CONFIG_UPDATE)
    - 0x60-0x7F: RPC Responses
    - 0x80-0x9F: Hub Services (REGISTRY_*, FLEET_STATUS_*)
    - 0xA0-0xBF: Pub/Sub (SUBSCRIBE, PUBLISH)
    - 0xC0-0xCF: Terminal Sessions (TERMINAL_REQUEST/ACCEPT/REJECT)
    
    `*Why Custom Protocol (not "native Reticulum"):*`
    - Request/response correlation via 16-byte request_id
    - Typed messages with structured payloads
    - Security limits (MAX_PAYLOAD_SIZE, strict msgpack parsing)
    - Terminal sessions with PTY over RNS Link (implemented)
    
    `*Styrene Hub (NomadNet Node)*`
    
    The fleet's configuration and identity authority, hosted on Reticulum. Acts as a `*propagation node*` for mesh communications and device discovery.
    
    The `*Styrene Community Hub*` is the planned first public release — an LXMF propagation node, RNS transport node, NomadNet page server, and styrened fleet manager bundled into a single deployable unit. No existing project packages all of these together; the Hub establishes Styrene's presence in the Reticulum ecosystem before fleet management features are complete.
    
    `*Hosted Content:*`
    - Device specifications (partition layouts, bootloader requirements)
    - NixOS configuration templates
    - Fleet manifests (which devices belong, their roles)
    - Identity registry (authorized devices and operators)
    - ISO hashes for integrity verification
    
    `*Hub Role in RPC:*`
    - Propagation node for LXMF messages between TUI and devices
    - Discovery endpoint for finding fleet devices on the mesh
    - Does NOT intercept or proxy RPC calls (direct TUI ↔ Device communication)
    - Provides authoritative device registry for fleet membership
    
    `*Why NomadNet:*`
    - Content replicates across the mesh (resilient)
    - Accessible over any Reticulum transport (WiFi, LoRa, packet radio)
    - Pages are simple to author and update
    - MeshChat already demonstrates the pattern
    
    `*Fleet Communication Protocol*`
    
    Fleet communication uses the `*Styrene wire protocol*` over LXMF. Messages are binary-encoded with msgpack payloads.
    
    `*Wire Format v2*`
    
    >>
    LXMF Message:
      FIELD_CUSTOM_TYPE (0xFB): b"styrene.io"
      FIELD_CUSTOM_DATA (0xFC): [PREFIX][VERSION][TYPE][REQUEST_ID][PAYLOAD]
    
    Wire Data Layout:
      PREFIX:     b"styrene.io:" (11 bytes)
      VERSION:    0x02 (1 byte)
      TYPE:       StyreneMessageType enum (1 byte)
      REQUEST_ID: 16 random bytes (for correlation)
      PAYLOAD:    msgpack-encoded data (variable)
    <<
    
    `*Request/Response Correlation*`
    
    - `*Request ID Generation*`: `os.urandom(16)` — 16 random bytes (NOT UUID)
    - `*Response Echoing*`: Device echoes the `request_id` in its response
    - `*Fire-and-forget*`: Use 16 zero bytes (`NO_CORRELATION`) for one-way messages
    - `*Timeout*`: 30-second default, raises `RPCTimeoutError` if exceeded
    
    >>
    # TUI side (RPCClient)
    request_id = os.urandom(16)  # 16 random bytes
    envelope = StyreneEnvelope(
        version=2,
        message_type=StyreneMessageType.STATUS_REQUEST,
        payload=b"",
        request_id=request_id,
    )
    await protocol.send_typed_message(device_hash, envelope)
    response = await asyncio.wait_for(pending[request_id], timeout=30.0)
    
    # Device side (RPCServer)
    # Receives envelope, echoes request_id in response
    response_envelope = create_status_response(status_data, request_id=envelope.request_id)
    await protocol.send_typed_message(source_hash, response_envelope)
    <<
    
    `*Message Type Examples*`
    
    `*STATUS_REQUEST (0x10) / STATUS_RESPONSE (0x11):*`
    >>
    Request:  [styrene.io:][0x02][0x10][<16-byte-id>][<empty>]
    Response: [styrene.io:][0x02][0x11][<16-byte-id>][msgpack({
                "uptime": 123456,
                "ip": "192.168.0.101",
                "services": ["reticulum", "styrened"],
                "disk_used": 4200000000,
                "disk_total": 28000000000
              })]
    <<
    
    `*EXEC (0x40) / EXEC_RESULT (0x60):*`
    >>
    Request:  [styrene.io:][0x02][0x40][<16-byte-id>][msgpack({
                "command": "systemctl",
                "args": ["status", "reticulum"]
              })]
    Response: [styrene.io:][0x02][0x60][<16-byte-id>][msgpack({
                "exit_code": 0,
                "stdout": "● reticulum.service...",
                "stderr": ""
              })]
    <<
    
    `*Security Model*`
    
    - All messages encrypted end-to-end (Reticulum identity keys)
    - Devices only accept commands from authorized operator identities
    - Identity authorization configured at provision time
    - Optional: Hub as identity authority for fleet-wide policies
    
    `*Data Flow*`
    
    `*Provisioning a New Device (x86 — USB Installer)*`
    
    >>
    1. Operator: Launch styrene-tui
    2. TUI: Fetch device catalog from styrene-edge (remote), detect USB drives
    3. Operator: Select target device (e.g., "minigmk", "t100ta")
    4. Operator: Configure hostname, WiFi, SSH keys
    5. TUI (Forge): Download NixOS ISO, write bootable USB, inject configs + polymerize.sh
    6. Operator: Boot target from USB, run polymerize.sh
    7. polymerize.sh: Partition, format, nixos-install (semi-attended)
    8. Device: Reboot into installed NixOS with styrened
    9. Device: Reticulum service starts, announces identity
    10. TUI: Device appears in fleet dashboard
    <<
    
    `*Provisioning a New Device (ARM — Direct SD)*`
    
    >>
    1. Operator: Launch styrene-tui, select ARM device from catalog
    2. TUI (Forge): Build SD image via nix build github:styrene-lab/styrene-edge#rpi4-sd
       (fetches from Cachix if available — no cross-compilation or local clone needed)
    3. TUI (Forge): Write to SD card with media writer
    4. Insert SD, power on — NixOS boots directly
    5. Device: styrened starts, announces on mesh
    6. TUI: Device appears in fleet dashboard
    <<
    
    `*Managing Existing Device*`
    
    >>
    1. TUI: Show fleet dashboard (devices from local inventory + live status)
    2. Operator: Select device
    3. TUI: Send status_request via LXMF
    4. Device: Respond with status_response
    5. Operator: View status, optionally send commands
    6. TUI → Device: LXMF message with command
    7. Device: Execute, respond with result
    <<
    
    `*Bandwidth Considerations*`
    
    
    The mesh handles control plane traffic. Data plane (large downloads) uses internet. SD card images for ARM SBCs are served from the Cachix binary cache (`styrene.cachix.org`) so any machine can fetch them without cross-compilation.
    
    `*Implementation Phases*`
    
    `*Phase 1: Local Provisioner — LARGELY COMPLETE*`
    
    TUI-driven workflow with integrated Forge for media preparation and polymerize scripts for installation.
    
    `*Forge components (in styrene-edge, to be absorbed into styrene-tui):*`
    - ✓ Device catalog with specs (minigmk, t100ta, q502l, rpi4, rpi-zero2w, rg35xx-h, r36s)
    - ✓ USB media writer (ISO download, partition, config injection)
    - ✓ Bundle builder (configs + polymerize.sh + WiFi + SSH keys)
    - ✓ Per-device polymerize.sh scripts (x86-generic, t100ta)
    - ✓ NixOS SD card images via Nix flake (rpi4, rpi-zero2w, rg35xx-h, r36s)
    - ✓ Cachix binary cache for pre-built aarch64 images
    - ✓ Install runbook tracking (versioned runbooks + result records)
    
    `*styrene-tui:*`
    - ✓ Textual TUI with device selection and fleet dashboard
    - ✓ Fleet inventory display
    - ⚠️ Forge absorption in progress — provisioning Python code migrating from styrene-edge into styrene-tui
    - ⚠️ Device catalog will be fetched from styrene-edge at runtime (not bundled)
    
    `*Deliverable:*` End-to-end provisioning from a single TUI — `*IN PROGRESS*` (Forge works standalone, absorption underway)
    
    `*Phase 2: Reticulum Integration ✅ COMPLETE*`
    
    Mesh connectivity for fleet communication is implemented.
    
    `*Completed:*`
    - ✓ LXMF message layer (send/receive via LXMFService)
    - ✓ RPC protocol (request/response correlation, timeouts, errors)
    - ✓ Wire protocol v2 (16-byte request_id, msgpack payloads)
    - ✓ Message models (StatusRequest/Response, ExecCommand/Result, etc.)
    - ✓ `*RPCServer*` (handles STATUS_REQUEST, EXEC, REBOOT, CONFIG_UPDATE, PING)
    - ✓ `*RPCClient*` (send requests, await correlated responses)
    - ✓ `*StyreneProtocol*` (typed message dispatch, handler registration)
    - ✓ `*AutoReplyHandler*` (respond to NomadNet/MeshChat users)
    - ✓ `*Device Discovery*` (RNS announce parsing, mesh topology tracking)
    - ✓ `*IPC Control Server*` (Unix socket for local CLI/daemon communication)
    - ✓ `*ConversationService*` (chat history, delivery tracking, threading, attachments)
    - ✓ `*ReadReceiptProtocol*` (ecosystem compatibility with Sideband/MeshChat)
    - ✓ `*NodeStore*` (persistent device discovery, identity→hash mapping)
    - ✓ `*TerminalService*` (remote shell via PTY over RNS Link)
    - ✓ `*IdentityConfig*` (display_name, icon for ecosystem compatibility)
    - ⚠️ `*Pub/Sub messages*` (defined in wire protocol, not yet implemented)
    
    `*Still TODO:*`
    - Hub integration (browse/download device specs from NomadNet)
    - Inject device Reticulum identity at provision time
    - Authorization checking (verify operator identity on devices)
    
    `*Deliverable:*` Live fleet status over mesh. ✅ ACHIEVED
    
    `*Phase 3: Full Fleet Management*`
    
    Complete fleet operations through the mesh.
    
    `*TUI:*`
    - Fleet dashboard with live status
    - Batch operations (update all, reboot all)
    - Configuration management and rollback
    - Audit logging
    
    `*Hub:*`
    - Device registry with status tracking
    - Config versioning
    - Fleet policies
    
    `*Deliverable:*` Complete fleet management without SSH.
    
    `*Supported Devices*`
    
    `*Active Devices*`
    
    
    `*Future Targets*`
    
    
    `*Layer 2 Mesh: BATMAN-adv*`
    
    Reticulum operates as an overlay network, agnostic to the underlying transport. For local fleet connectivity, we use BATMAN-adv (https://www.open-mesh.org/doc/batman-adv/Doc-overview.html) (Better Approach to Mobile Ad-hoc Networking - Advanced) to provide Layer 2 mesh networking.
    
    `*Why Two Layers?*`
    
    
    `*They are complementary, not competing:*`
    - BATMAN-adv handles: "How do I get an Ethernet frame from radio A to radio B across 3 hops?"
    - Reticulum handles: "How do I send an encrypted message to cryptographic identity X?"
    
    Reticulum sees BATMAN-adv's bat0 interface as just another network interface.
    
    `*Network Architecture*`
    
    >>
    ┌─────────────────────────────────────────────────────────────────────────────┐
    │                         Styrene Fleet Network                                │
    ├─────────────────────────────────────────────────────────────────────────────┤
    │                                                                              │
    │   [Internet/Home LAN]                                                        │
    │          │                                                                   │
    │          │ eth0 (WAN)                                                        │
    │   ┌──────┴──────┐                                                           │
    │   │  Hub Node   │  RPi4B or similar                                         │
    │   │ ─────────── │                                                           │
    │   │ • Reticulum │  - Transport Node (full RNS)                              │
    │   │   Hub       │  - Styrene Hub (NomadNet)                                 │
    │   │ • BATMAN-adv│  - Gateway mode (bridges to LAN)                          │
    │   │   gateway   │  - Optional: USB RNode for LoRa                           │
    │   └──────┬──────┘                                                           │
    │          │ eth0 → bat0 (bridged)                                            │
    │          │                                                                   │
    │   ┌──────┴──────┐                                                           │
    │   │ Mesh Router │  GL.iNet Opal or similar OpenWrt device                   │
    │   │ ─────────── │                                                           │
    │   │ • BATMAN-adv│  - Mesh coordinator                                        │
    │   │   node      │  - WiFi AP for fleet devices                              │
    │   │ • 802.11s   │  - Optional: 2nd radio for backhaul                       │
    │   │   mesh      │                                                           │
    │   └──────┬──────┘                                                           │
    │          │ bat0 (mesh interface)                                            │
    │          │                                                                   │
    │   ┌──────┴────────────────┬────────────────────┐                            │
    │   │                       │                    │                            │
    │ [Fleet    ]         [Fleet    ]          [Fleet    ]                        │
    │ [Device 1 ]         [Device 2 ]          [Device 3 ]                        │
    │  RPi Zero 2W         T100TA              RPi 4                              │
    │  • BATMAN-adv        • BATMAN-adv        • BATMAN-adv                       │
    │    client              client              client                           │
    │  • RNS               • RNS               • RNS                              │
    │  • LXMF              • LXMF              • LXMF                             │
    │                                                                              │
    └─────────────────────────────────────────────────────────────────────────────┘
    <<
    
    `*Role Separation*`
    
    
    `*Styrix Configuration*`
    
    Styrix (NixOS edge flavor) fleet devices use the `batman-mesh.nix` module from `styrene-edge/sbc/common/`:
    
    >>
    { config, lib, ... }:
    
    {
      imports = [ ../common/batman-mesh.nix ];
    
      styrene.mesh = {
        enable = true;
        meshId = "styrene";
        meshKey = lib.mkDefault "changeme-styrene-fleet";
        gwMode = "client";  # or "server" for hub, "off" for offline
      };
    }
    <<
    
    The module handles kernel module loading, batctl installation, NetworkManager 802.11s mesh profile creation, and a systemd service to attach the interface to bat0.
    
    `*Implementation Notes*`
    
    `*Phase 1*`: Devices connect via standard WiFi (no BATMAN-adv yet). Reticulum uses AutoInterface on wlan0.
    
    `*Phase 2*`: Add BATMAN-adv to fleet devices. Reticulum's AutoInterface switches to bat0. Mesh router (Opal) provides L2 backbone.
    
    `*Phase 3*`: Add LoRa gateways for long-range/offline scenarios. Reticulum automatically discovers and uses multiple transports.
    
    `*Open Questions*`
    
    1. `*Hub hosting*`: Run on existing infrastructure (brutus K8s) or dedicated device?
       - K8s: Easy to deploy, but tied to LAN
       - Dedicated: Can have LoRa interface for true off-grid
    
    2. `*Identity lifecycle*`: What happens when a device is decommissioned?
       - Revocation list on Hub?
       - Time-limited credentials?
    
    3. `*Offline provisioning*`: How to handle fully air-gapped scenarios?
       - Pre-cache everything on USB?
       - See SOPS-NIX-ADOPTION.md for secrets handling in airgapped environments
    
    `*References*`
    
    - BATMAN-adv Documentation (https://www.open-mesh.org/doc/batman-adv/Doc-overview.html)
    - Reticulum Network Stack (https://github.com/markqvist/Reticulum)
    - MeshChat (https://github.com/liamcottle/reticulum-meshchat) - Pattern for integrated mesh + TUI tooling
    - NomadNet (https://github.com/markqvist/NomadNet) - Decentralized pages over Reticulum
    - LXMF (https://github.com/markqvist/LXMF) - Messaging protocol for Reticulum
    - Textual (https://github.com/Textualize/textual) - Python TUI framework
    
    `*Revision History*`
    

  styrene-tui-vision.mu: |
    `!Styrene TUI Vision!`
    
    The terminal user interface for Styrene fleet management — designed to be comprehensive enough to serve as an operational environment.
    
    `*Status*`: Active — Last aligned with implementation 2026-02-19
    
    > `*Architecture Reference*`: See architecture-decisions.md (./architecture-decisions.md) for high-level decisions and document hierarchy.
    
    `*Design Philosophy*`
    
    `*"TUI as OS"*`
    
    Styrene's TUI aims to be complete enough that an operator could manage their entire edge fleet without leaving the terminal. This doesn't mean reinventing every tool — it means providing seamless integration with the Unix ecosystem while maintaining a cohesive interface.
    
    `*Core principle*`: Delegate to `$EDITOR` for text editing. Neovim, Helix, Vim, or nano — whatever the operator prefers. Styrene handles orchestration and visualization; specialized tools handle their domains.
    
    `*Single Operator Interface*`
    
    The TUI is the single entry point for operators. `pip install styrene-tui` gives you everything:
    - `*styrened*` (pulled as dependency) — mesh daemon, RPC, discovery, LXMF
    - `*Forge provisioning*` (absorbed) — media writing, disk detection, device catalog, bundles
    - `*LXMF messaging*` — replaces NomadNet client and MeshChat for operators
    - `*Fleet management*` — dashboard, device console, batch operations
    
    An operator should never need to install NomadNet, MeshChat, or clone styrene-edge to participate in the mesh or provision devices.
    
    `*Daemon Lifecycle*`
    
    On operator workstations, the TUI manages styrened as a subprocess — starts it on launch, tears it down on exit. No `systemctl enable` required. The IPC contract (Unix socket) is the same whether styrened is a managed subprocess or a permanent systemd service on an edge device. This means:
    
    - The TUI does `*not*` initialize the RNS singleton directly
    - The TUI communicates with styrened exclusively via IPC (`ControlClient`)
    - styrened owns the mesh stack, discovery, and conversation state
    - The TUI is a presentation layer that renders what the daemon reports
    
    `*Visual Inspiration*`
    
    `*Layout density*`: eDEX-UI (https://github.com/GitSquared/edex-ui) — multiple information panels visible simultaneously, real-time status updates, progress visualization.
    
    `*Aesthetic*`: Specularium (https://github.com/styrene-lab/specularium) Imperial CRT theme — green phosphor terminal aesthetic, scanline effects, VT323 monospace font, subtle glow on active elements. Think Warhammer 40K cogitator meets retro-futurism.
    
    `*Philosophy*`: Tool first, aesthetic second. Every panel earns its screen space through utility. The Imperial CRT theme adds atmosphere without sacrificing function.
    
    `*Theme: Imperial CRT*`
    
    Translated from Specularium's CSS to Textual's design system.
    
    `*Color Palette*`
    
    >>
    ┌─ Imperial CRT Phosphor Palette ─────────────────────────────────────────────┐
    │                                                                              │
    │  PRIMARY (Green Phosphor)                                                    │
    │  ├── Bright:  #39ff14  ████  Active elements, highlights, success           │
    │  ├── Medium:  #32cd32  ████  Standard text, borders                         │
    │  ├── Dim:     #228b22  ████  Secondary text, inactive elements              │
    │  ├── Dark:    #1a5c1a  ████  Subtle borders, separators                     │
    │  └── Darker:  #0d2d0d  ████  Panel backgrounds, hover states                │
    │                                                                              │
    │  BACKGROUND                                                                  │
    │  └── Off-black: #0a0a0a ████  Screen background (not pure black)            │
    │                                                                              │
    │  ACCENTS (Status Colors)                                                     │
    │  ├── Info:    #74c0fc  ████  Information, scanning, network                 │
    │  ├── Warning: #ffa94d  ████  Warnings, pending states                       │
    │  ├── Danger:  #ff6b6b  ████  Errors, offline, destructive actions           │
    │  └── Success: #69db7c  ████  Completion, online, verified                   │
    │                                                                              │
    │  GLOW EFFECTS                                                                │
    │  ├── Bright glow: rgba(57, 255, 20, 0.3)  Active element shadows            │
    │  └── Dim glow:    rgba(57, 255, 20, 0.15) Subtle ambient glow               │
    │                                                                              │
    └──────────────────────────────────────────────────────────────────────────────┘
    <<
    
    `*Textual Theme Definition*`
    
    >>
    # styrene/themes/imperial_crt.py
    from textual.theme import Theme
    
    IMPERIAL_CRT = Theme(
        name="imperial-crt",
    
        # Core phosphor green palette
        primary="#32cd32",          # Medium green - main accent
        secondary="#1a5c1a",        # Dark green - secondary elements
        accent="#39ff14",           # Bright green - highlights, active
    
        # Text and backgrounds
        foreground="#32cd32",       # Medium green text
        background="#0a0a0a",       # Off-black background
        surface="#0d2d0d",          # Dark green surface (panels)
        panel="#1a5c1a",            # Slightly lighter panels
    
        # Status colors
        success="#69db7c",          # Verified, online, complete
        warning="#ffa94d",          # Pending, caution
        error="#ff6b6b",            # Offline, errors, danger
    
        dark=True,
    
        variables={
            # Borders glow with the phosphor color
            "border": "#228b22",
            "border-blurred": "#1a5c1a",
    
            # Cursor matches the bright phosphor
            "block-cursor-background": "#39ff14",
            "block-cursor-foreground": "#0a0a0a",
    
            # Footer uses the accent color for keys
            "footer-key-foreground": "#39ff14",
            "footer-background": "#0d2d0d",
    
            # Input selection with phosphor glow
            "input-selection-background": "#39ff14 25%",
            "input-cursor-background": "#39ff14",
    
            # Scrollbar in theme
            "scrollbar": "#1a5c1a",
            "scrollbar-hover": "#228b22",
            "scrollbar-active": "#32cd32",
        },
    )
    <<
    
    `*TCSS Styling*`
    
    >>
    /* styrene/styles/imperial_crt.tcss */
    
    /* === Base Screen === */
    Screen {
        background: #0a0a0a;
    }
    
    /* === Panel Styling === */
    .panel {
        border: solid #228b22;
        background: #0d2d0d;
        padding: 1;
    }
    
    .panel:focus-within {
        border: solid #32cd32;
    }
    
    .panel-title {
        color: #39ff14;
        text-style: bold;
        text-transform: uppercase;
    }
    
    /* === Status Indicators === */
    .status-online {
        color: #69db7c;
    }
    
    .status-offline {
        color: #ff6b6b;
    }
    
    .status-pending {
        color: #ffa94d;
    }
    
    .status-scanning {
        color: #74c0fc;
    }
    
    /* === Data Tables === */
    DataTable {
        background: #0d2d0d;
    }
    
    DataTable > .datatable--header {
        background: #1a5c1a;
        color: #39ff14;
        text-style: bold;
    }
    
    DataTable > .datatable--cursor {
        background: #1a5c1a;
        color: #39ff14;
    }
    
    DataTable > .datatable--hover {
        background: #0d2d0d;
    }
    
    /* === Progress Bars === */
    ProgressBar > .bar--bar {
        color: #228b22;
    }
    
    ProgressBar > .bar--complete {
        color: #39ff14;
    }
    
    ProgressBar.-success > .bar--complete {
        color: #69db7c;
    }
    
    ProgressBar.-warning > .bar--complete {
        color: #ffa94d;
    }
    
    /* === Input Fields === */
    Input {
        background: #0a0a0a;
        border: solid #1a5c1a;
        color: #32cd32;
    }
    
    Input:focus {
        border: solid #32cd32;
    }
    
    Input.-valid {
        border: solid #69db7c;
    }
    
    Input.-invalid {
        border: solid #ff6b6b;
    }
    
    /* === Buttons === */
    Button {
        background: #0d2d0d;
        border: solid #228b22;
        color: #32cd32;
    }
    
    Button:hover {
        background: #1a5c1a;
        border: solid #32cd32;
        color: #39ff14;
    }
    
    Button:focus {
        border: solid #39ff14;
    }
    
    Button.-primary {
        background: #1a5c1a;
        border: solid #32cd32;
        color: #39ff14;
    }
    
    Button.-danger {
        border: solid #ff6b6b;
        color: #ff6b6b;
    }
    
    Button.-danger:hover {
        background: #2d0d0d;
    }
    
    /* === Footer === */
    Footer {
        background: #0d2d0d;
        border-top: solid #1a5c1a;
    }
    
    Footer > .footer--key {
        color: #39ff14;
        background: transparent;
    }
    
    Footer > .footer--description {
        color: #228b22;
    }
    
    /* === Header === */
    Header {
        background: #0a0a0a;
        border-bottom: solid #228b22;
        color: #39ff14;
    }
    
    /* === Log/Activity Styling === */
    .log-entry {
        color: #228b22;
    }
    
    .log-entry.-info {
        color: #32cd32;
    }
    
    .log-entry.-success {
        color: #69db7c;
    }
    
    .log-entry.-warning {
        color: #ffa94d;
    }
    
    .log-entry.-error {
        color: #ff6b6b;
    }
    
    .log-timestamp {
        color: #1a5c1a;
    }
    
    /* === Phosphor Glow Effect (simulated) === */
    .glow {
        text-style: bold;
        color: #39ff14;
    }
    <<
    
    `*Architecture*`
    
    `*Framework: Textual (Python)*`
    
    Textual (https://textual.textualize.io/) provides the foundation:
    
    - `*CSS-like theming (TCSS)*` — Hot-reloadable styles, Imperial CRT aesthetic achievable
    - `*Rich widget library*` — DataTable, Tree, ProgressBar, Input, Button
    - `*Async-native*` — Non-blocking I/O for mesh operations
    - `*16.7M colors*` — Full phosphor green palette available
    - `*Low enough footprint*` — Runs on Pi Zero (per Textualize docs)
    - `*Native RNS integration*` — Same Python ecosystem as Reticulum
    
    `*Reticulum Integration (via styrened IPC)*`
    
    The TUI communicates with the Reticulum mesh through styrened's IPC interface (Unix socket), `*not*` by initializing RNS directly. styrened owns the mesh stack; the TUI is a presentation layer.
    
    `*IPC provides:*`
    - Device discovery and mesh topology (`query_devices()`, `sub_devices()`)
    - LXMF messaging (`query_conversations()`, `cmd_send_chat()`, `sub_messages()`)
    - Fleet RPC (`cmd_exec()`, `cmd_device_status()`)
    - Identity information (`query_identity()`)
    - Configuration (`query_config()`)
    
    > `*Note*`: Fleet communication uses the `*Styrene wire protocol*` over LXMF. The TUI renders results; styrened handles all protocol details. See provisioning-vision.md (./provisioning-vision.md) for wire protocol details.
    
    `*Resource Optimization*`
    
    
    `*Phase 1*`: Write clean, type-annotated Python. Profile before optimizing.
    
    `*Integration with $EDITOR*`
    
    When editing configuration, Styrene suspends and launches the user's preferred editor:
    
    >>
    import os
    import subprocess
    import tempfile
    
    def edit_config(content: str, suffix: str = ".yaml") -> str | None:
        """Open content in user's preferred editor, return modified content."""
        editor = os.environ.get("EDITOR", "vi")
    
        with tempfile.NamedTemporaryFile(mode="w", suffix=suffix, delete=False) as f:
            f.write(content)
            temp_path = f.name
    
        try:
            result = subprocess.run([editor, temp_path])
            if result.returncode == 0:
                with open(temp_path) as f:
                    return f.read()
            return None
        finally:
            os.unlink(temp_path)
    <<
    
    `*Screen Design*`
    
    `*Main Dashboard*`
    
    >>
    ┌─ STYRENE ─────────────────────────────────────────────────────────────────────┐
    │ ┌─ FLEET STATUS ─────────────┐ ┌─ RETICULUM ────────────────────────────────┐ │
    │ │ ONLINE:  12 │ OFFLINE: 2  │ │ IDENTITY: 3f8a...c21b                      │ │
    │ │ PENDING:  3 │ ERROR:   0  │ │ HUB: styrene.hub [CONNECTED]               │ │
    │ │                           │ │ INTERFACES: WiFi ✓  LoRa ✓  TCP ✓          │ │
    │ └───────────────────────────┘ └────────────────────────────────────────────┘ │
    │ ┌─ DEVICES ─────────────────────────────────────────────────────────────────┐ │
    │ │ NAME          TYPE         IP              STATUS    LAST SEEN           │ │
    │ │ ▸ rpi-01      rpi-zero2w   192.168.0.101   ONLINE    2m ago              │ │
    │ │   rpi-02      rpi-zero2w   192.168.0.102   ONLINE    5m ago              │ │
    │ │   t100ta-01   t100ta       192.168.0.110   OFFLINE   3h ago              │ │
    │ │   x86-dev     x86-generic  192.168.0.120   ONLINE    1m ago              │ │
    │ │   libre-01    libre-board  —               PENDING   —                   │ │
    │ └───────────────────────────────────────────────────────────────────────────┘ │
    │ ┌─ ACTIVITY ────────────────────────────────────────────────────────────────┐ │
    │ │ 14:32:15  rpi-01      Status check: healthy                              │ │
    │ │ 14:31:42  t100ta-01   Connection lost                                    │ │
    │ │ 14:30:00  x86-dev     Provisioning complete                              │ │
    │ └───────────────────────────────────────────────────────────────────────────┘ │
    │ [P]ROVISION  [D]EVICE  [C]ONFIG  [H]UB  [Q]UIT                                │
    └───────────────────────────────────────────────────────────────────────────────┘
    <<
    
    `*Provisioning Screen*`
    
    >>
    ┌─ PROVISION NEW DEVICE ────────────────────────────────────────────────────────┐
    │ ┌─ STORAGE DEVICES ─────────────────────────────────────────────────────────┐ │
    │ │   DEVICE       SIZE      TYPE       LABEL                                │ │
    │ │ ▸ /dev/sdb     32 GB     USB        SANDISK_ULTRA                        │ │
    │ │   /dev/sdc     128 GB    USB-SSD    SAMSUNG_T7                           │ │
    │ │   /dev/mmcblk0 64 GB     SD         —                                    │ │
    │ └───────────────────────────────────────────────────────────────────────────┘ │
    │ ┌─ DEVICE TYPE ─────────────────────────────────────────────────────────────┐ │
    │ │ ○ x86-generic    Standard UEFI x86_64                                    │ │
    │ │ ● t100ta         ASUS T100TA (32-bit UEFI, Bay Trail)                    │ │
    │ │ ○ rpi-4          Raspberry Pi 4 (arm64)                                  │ │
    │ │ ○ rpi-zero2w     Raspberry Pi Zero 2W (arm64)                            │ │
    │ └───────────────────────────────────────────────────────────────────────────┘ │
    │ ┌─ CONFIGURATION ───────────────────────────────────────────────────────────┐ │
    │ │ HOSTNAME: t100ta-02                                                      │ │
    │ │ WIFI SSID: ████████████    WIFI PSK: ••••••••••••                        │ │
    │ │ SSH KEYS: ~/.ssh/id_ed25519.pub [LOADED]                                 │ │
    │ │ [E]DIT NIXOS CONFIG...                                                   │ │
    │ └───────────────────────────────────────────────────────────────────────────┘ │
    │ TARGET: /dev/sdb (32 GB) → t100ta                                            │
    │ ⚠ WARNING: THIS WILL ERASE ALL DATA ON TARGET DEVICE                         │
    │ [W]RITE IMAGE    [B]ACK    [Q]UIT                                            │
    └───────────────────────────────────────────────────────────────────────────────┘
    <<
    
    `*Provisioning Progress Screen*`
    
    >>
    ┌─ PROVISIONING: t100ta-02 ─────────────────────────────────────────────────────┐
    │                                                                               │
    │  ┌─ PROGRESS ──────────────────────────────────────────────────────────────┐  │
    │  │                                                                         │  │
    │  │  [████████████████████████████████████████░░░░░░░░░░░░░░]  68%         │  │
    │  │                                                                         │  │
    │  │  STAGE: WRITING MEDIA                                                   │  │
    │  │  ELAPSED: 02:34    REMAINING: ~1:12                                     │  │
    │  │                                                                         │  │
    │  └─────────────────────────────────────────────────────────────────────────┘  │
    │                                                                               │
    │  ┌─ STAGE HISTORY ─────────────────────────────────────────────────────────┐  │
    │  │  ✓ DOWNLOADING ISO                                          00:45      │  │
    │  │  ✓ VERIFYING HASH                                           00:12      │  │
    │  │  ◐ WRITING MEDIA...                                         —          │  │
    │  │  ○ INJECTING CONFIG                                                    │  │
    │  │  ○ FINALIZING                                                          │  │
    │  └─────────────────────────────────────────────────────────────────────────┘  │
    │                                                                               │
    │  ┌─ LIVE OUTPUT ───────────────────────────────────────────────────────────┐  │
    │  │  Writing to /dev/sdb...                                                │  │
    │  │  1.2 GB / 1.8 GB                                                       │  │
    │  └─────────────────────────────────────────────────────────────────────────┘  │
    │                                                                               │
    │ [A]BORT    [L]OG TO FILE                                                      │
    └───────────────────────────────────────────────────────────────────────────────┘
    <<
    
    `*Device Details Screen*`
    
    >>
    ┌─ DEVICE: rpi-01 ──────────────────────────────────────────────────────────────┐
    │ ┌─ IDENTITY ────────────────────────────────────────────────────────────────┐ │
    │ │ TYPE:      rpi-zero2w            HOSTNAME: rpi-01                        │ │
    │ │ RETICULUM: 7b2f...a91d           IP: 192.168.0.101                       │ │
    │ │ NIXOS: 24.05                     PROVISIONED: 2025-01-15                 │ │
    │ └───────────────────────────────────────────────────────────────────────────┘ │
    │ ┌─ STATUS (via LXMF) ───────────────────────────────────────────────────────┐ │
    │ │ UPTIME:   14d 3h 22m             LOAD: 0.12 0.08 0.05                    │ │
    │ │ MEMORY:   128 MB / 512 MB        DISK: 4.2 GB / 28 GB                    │ │
    │ │ TEMP:     42°C                   SERVICES: 4/4 HEALTHY                   │ │
    │ └───────────────────────────────────────────────────────────────────────────┘ │
    │ ┌─ SERVICES ────────────────────────────────────────────────────────────────┐ │
    │ │ reticulum.service              ACTIVE (RUNNING)   ✓                      │ │
    │ │ lxmf-handler.service           ACTIVE (RUNNING)   ✓                      │ │
    │ │ node-exporter.service          ACTIVE (RUNNING)   ✓                      │ │
    │ │ NetworkManager.service         ACTIVE (RUNNING)   ✓                      │ │
    │ └───────────────────────────────────────────────────────────────────────────┘ │
    │ ┌─ ACTIONS ─────────────────────────────────────────────────────────────────┐ │
    │ │ [S]HELL — NomadNet terminal (if available)                               │ │
    │ │ [C]ONFIG — view device configuration                                     │ │
    │ │ [L]OGS — view recent logs (via LXMF)                                     │ │
    │ │ [R]EBOOT — request device reboot                                         │ │
    │ │ [U]PDATE — trigger config rebuild                                        │ │
    │ └───────────────────────────────────────────────────────────────────────────┘ │
    │ [B]ACK TO FLEET    [Q]UIT                                                     │
    └───────────────────────────────────────────────────────────────────────────────┘
    <<
    
    `*Project Structure*`
    
    >>
    styrene-tui/
    ├── pyproject.toml               # depends: styrened, textual, pyyaml
    ├── README.md
    ├── src/styrene/
    │   ├── __init__.py
    │   ├── __main__.py              # Entry point (manages styrened lifecycle)
    │   ├── app.py                   # Textual App class
    │   ├── screens/
    │   │   ├── __init__.py
    │   │   ├── dashboard.py         # Main fleet overview
    │   │   ├── inbox.py             # LXMF inbox (conversations)
    │   │   ├── conversation.py      # Chat thread with a peer
    │   │   ├── provision.py         # Device provisioning flow (Forge UI)
    │   │   ├── device.py            # Single device details
    │   │   ├── explore.py           # Non-Styrene Reticulum announces
    │   │   └── hub.py               # NomadNet hub browser [TODO]
    │   ├── widgets/
    │   │   ├── __init__.py
    │   │   ├── device_table.py      # Fleet device listing
    │   │   ├── storage_picker.py    # USB/SD device selection
    │   │   ├── progress_panel.py    # Provisioning progress
    │   │   └── activity_log.py      # Recent activity feed
    │   ├── services/
    │   │   ├── __init__.py
    │   │   ├── daemon.py            # styrened lifecycle (start/stop subprocess)
    │   │   ├── ipc.py               # ControlClient wrapper for TUI
    │   │   ├── storage.py           # USB/SD detection
    │   │   ├── provisioner.py       # Media preparation (Forge, absorbed)
    │   │   ├── media_writer.py      # Bootable media writer (from Forge)
    │   │   ├── bundle_builder.py    # Config bundler (from Forge)
    │   │   ├── catalog.py           # Device catalog (fetched from styrene-edge)
    │   │   └── fleet.py             # Fleet inventory
    │   ├── models/
    │   │   ├── __init__.py
    │   │   ├── device.py            # Device data model
    │   │   ├── fleet.py             # Fleet inventory
    │   │   └── config.py            # Configuration schemas
    │   ├── themes/
    │   │   ├── __init__.py
    │   │   └── imperial_crt.py      # Imperial CRT theme
    │   └── styles/
    │       └── imperial_crt.tcss    # Textual CSS
    └── tests/
    <<
    
    `*Phase 1 Implementation Plan*`
    
    `*Milestone 1.1: Project Scaffolding*`
    `*Goal*`: Runnable TUI shell with Imperial CRT theme.
    - Initialize Python project with pyproject.toml (uv)
    - Create Textual App class with screen routing
    - Implement Imperial CRT theme
    - Dashboard, Provision, Device screens (empty shells)
    - Keyboard navigation (P, D, B, Q)
    
    `*Milestone 1.2: Storage Detection*`
    `*Goal*`: Detect and list USB/SD storage devices.
    - Platform-specific enumeration (Linux: /sys/block, macOS: diskutil)
    - StoragePicker widget
    - Device name, size, type, label display
    - Removable vs fixed highlighting
    
    `*Milestone 1.3: Device Specifications*`
    `*Goal*`: Load and display device specifications.
    - Device spec schema (YAML)
    - Load from ~/.config/styrene/devices/
    - Device selector with specs
    - Device-specific notes display
    
    `*Milestone 1.4: Configuration Input*`
    `*Goal*`: Gather provisioning configuration.
    - Hostname input
    - WiFi SSID/PSK fields (show/hide toggle)
    - SSH key file picker
    - "Edit NixOS config" → $EDITOR
    
    `*Milestone 1.5: Media Preparation (Forge Absorption)*`
    `*Goal*`: Prepare bootable NixOS media from within the TUI.
    - ✓ Forge components implemented in `styrene-edge` (media_writer, bundle_builder, disk_detect, devices.yaml)
    - ⚠️ Forge absorption in progress — migrating Python provisioning code into styrene-tui
    - Device catalog fetched from styrene-edge at runtime (no local clone required)
    - Handles: ISO download, USB writing, config bundling, polymerize.sh injection, Nix SD image builds
    
    `*Milestone 1.6: Fleet Dashboard (Live) ✓*`
    `*Goal*`: Display fleet with live status via LXMF RPC.
    - Fleet inventory format (YAML)
    - DeviceTable widget
    - Status indicators (ONLINE/OFFLINE/PENDING)
    - Navigation to Device Details
    - Live status requests via LXMF ('s' key binding)
    - RPC client integration with timeout handling
    
    `*Milestone 1.7: Device Details (Static)*`
    `*Goal*`: Device info with action stubs.
    - Device Details screen
    - Action buttons (Shell, Config, Logs, Reboot, Update)
    - $EDITOR integration for config viewing
    
    `*Phase 1 Status — LARGELY COMPLETE ✅*`
    - ✓ Imperial CRT themed TUI
    - ✓ USB/SD storage detection
    - ✓ Device type selection with specs
    - ✓ Configuration (hostname, WiFi, SSH keys)
    - ✓ NixOS config editing via $EDITOR
    - ✓ Media preparation engine (Forge components in styrene-edge, proven)
    - ✓ Fleet inventory display
    - ✓ Device details view
    - ⚠️ Forge absorption in progress — provisioning code migrating into styrene-tui
    - ⚠️ Device catalog fetch from styrene-edge at runtime (not yet implemented)
    
    `*Phase 2: Reticulum Integration ✅ LARGELY COMPLETE*`
    
    `*Completed (in styrened v0.3.6+):*`
    - ✓ LXMF transport layer (LXMFService)
    - ✓ Wire protocol v2 (16-byte random request_id, NOT UUID)
    - ✓ `*RPCServer*` — Handles STATUS_REQUEST, EXEC, REBOOT, CONFIG_UPDATE, PING
    - ✓ `*RPCClient*` — Send requests, await correlated responses
    - ✓ Message models (StatusResponse, ExecResult, RebootResult, etc.)
    - ✓ Timeout handling (30s default, RPCTimeoutError)
    - ✓ Error handling (RPCTransportError, RPCInvalidResponseError)
    - ✓ `*AutoReplyHandler*` — Respond to NomadNet/MeshChat users
    - ✓ `*Device Discovery + NodeStore*` — RNS announce parsing with persistence
    - ✓ `*IPC Control Server*` — Unix socket for local CLI/TUI
    - ✓ `*ConversationService*` — Chat history, delivery tracking, threading, attachments
    - ✓ `*ReadReceiptProtocol*` — Ecosystem compatibility with Sideband/MeshChat
    - ✓ `*TerminalService*` — Remote shell via PTY over RNS Link
    - ✓ `*IdentityConfig*` — Display name and icon for ecosystem visibility
    
    `*TUI integration path (IPC-only):*`
    - ⚠️ TUI currently initializes RNS singleton directly (library mode) — needs migration to IPC-only
    - TUI should use `ControlClient` for all mesh operations (`query_*`, `cmd_*`, `sub_*`)
    - TUI manages styrened as subprocess on operator workstations
    - IPC event subscriptions (`sub_devices()`, `sub_messages()`) replace polling
    
    `*Still TODO:*`
    - ⚠ Hub connection as propagation node for discovery
    - Device spec download from Hub (NomadNet integration)
    - Inject device Reticulum identity at provision time
    
    `*Phase 3: Full Fleet Operations (Future)*`
    - Batch operations (update all, reboot all)
    - Configuration management and rollback
    - Audit logging
    - Multi-operator support
    - NomadNet terminal integration
    - Hub-mediated device discovery
    - Full LXMF client (replace NomadNet/MeshChat for operators — basic messaging already in Phase 2)
    
    `*References*`
    
    - Textual Documentation (https://textual.textualize.io/)
    - Specularium (https://github.com/styrene-lab/specularium) — Imperial CRT theme source
    - eDEX-UI (https://github.com/GitSquared/edex-ui) — Layout inspiration
    - NomadNet (https://github.com/markqvist/NomadNet) — Python TUI on Reticulum
    - provisioning-vision.md (./provisioning-vision.md) — Companion document
    
    `*Revision History*`
    

